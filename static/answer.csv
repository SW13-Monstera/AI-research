data_id,problem_id,assign,keyword_content,sim_content,problem,user_answer,reference,score
1,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 개인 PC에 text로 저장된다. 세션은 접속중인 웹 서버에 Object로 저장된다. 속도는 세션보다 쿠키가 더 빠르다. 왜냐하면 세션은 DB와 통신을 해야하기 때문이다.
",https://hahahoho5915.tistory.com/32,
2,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"세션이 쿠키에 비해 보안도 높은 편이나 쿠키를 사용하는 이유는세션은 서버에 저장되고, 서버자원을 사용하기 때문에 사용자가 많을 경우 소모되는 자원이 상당하다.이러한 자원관리 차원에서 쿠키와 세션을 적절한 요소 및 기능에 병행 사용하여,서버 자원의 낭비를 방지하며 웹사이트의 속도를 높일 수 있다. ",https://hahahoho5915.tistory.com/32,
3,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키와 세션의 가장 큰 차이점은 정보가 저장되는 위치입니다. 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다. 그 이유는 세션은 서버의 처리가 필요하기 때문입니다. ",https://interconnection.tistory.com/74,
4,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 보안성이 좋습니다. , https://interconnection.tistory.com/74,
5,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키도 만료시간이 있지만 파일로 저장되기 때문에 브라우저를 종료해도 계속해서 정보가 남아 있을 수 있습니다. 또한 만료기간을 넉넉하게 잡아두면 쿠키삭제를 할 때 까지 유지될 수도 있습니다. 반면에 세션도 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제됩니다. 예를 들어, 크롬에서 다른 탭을 사용해도 세션을 공유됩니다. 다른 브라우저를 사용하게 되면 다른 세션을 사용할 수 있습니다. ",https://interconnection.tistory.com/74,
6,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키에 정보가 있기 때문에 서버에 요청시 속도가 빠르고 세션은 정보가 서버에 있기 때문에 처리가 요구되어 비교적 느린 속도를 가집니다. 
",https://interconnection.tistory.com/74,
7,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,쿠키는 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드디스크에 저장하고 세션은 서버의 메모리에 저장합니다. 저장할 때 쿠키는 text형식으로 저장하고 세션은 Object 형식으로 저장합니다. ,https://devuna.tistory.com/23,
8,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,쿠키는 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버의 자원을 사용하지 않는다. 하지만 세션은 서버에 저장되고 서버의 메모리로 로딩이 되기 때문에 세션이 생길때마다 서버의 리소스를 차지한다. ,https://devuna.tistory.com/23,
9,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 저장할 때 expires 속성을 정의해 무효화 시키면 삭제될 날짜를 지정할 수 있다. (따로 지정되지 않은 경우에는 브라우저 종료시 만료) 반면에 세션은 클라이언트가 로그아웃하거나, 설정한 시간동안 반응이 없을경우 무효화 되기 때문에 정확한 시점을 알 수 없다. ",https://devuna.tistory.com/23,
10,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 자동완성이나, 팝업 일주일간 보지 않기 등 사용자의 편의를 위하는 것이지만  지워져도 되고, 조작되거나 가로채이더라도 큰 지장이 없는 수준의 정보들을 저장하는데 사용됩니다. 그리고 사용자나 다른 누군가에게 노출되면 안되는 중요한 정보들은 세션으로 서버안에서 다뤄집니다. 쿠키로 노출시켜서는 안될 정보들이 있고, 세션을 남발하면 서버에 부담이 되어 과부하가 일어나기 때문에 웹을 설계할 때는 이 정보는 쿠키에 저장할 지 세션에 저장할 지 적절한 판단을 내릴 수 있어야 합니다.",https://devuna.tistory.com/23,
11,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,쿠키는 클라이언트 로컬에 저장되는 Key-Value쌍의 작은 데이터 파일입니다. 그리고 세션은 브라우저가 종료되기 전까지 클라이언트의 요청을 유지하게 해주는 기술입니다.,https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582,
12,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키와 세션의 차이점은 저장위치, 보안, Lifecycle, 속도 총 4가지 입니다. 쿠키는 로컬에, 세션은 로컬과 서버에 저장됩니다. 쿠키는 탈취와 변조가 가능하지만, 세션은 ID값만 가지고 있고 서버에도 저장이 되어있기 때문에 상대적으로 안전합니다. 쿠키는 브라우저를 종료해도 파일로 남아있지만, 세션은 브라우저 종료시 세션을 삭제합니다. 쿠키는 파일에서 읽기 때문에 상대적으로 빠르고, 세션은 요청마다 서버에서 처리를 해야하기 때문에 비교적 느립니다. ",https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582,
13,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 클라이언트, 세션 정보는 서버 측에 저장됩니다.",https://junhyunny.github.io/information/cookie-and-session/,
14,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,세션은 웹 서버에 저장되고 쿠키는 클라이언트(접속자 PC)에 저장된다. 세션은 Object로 저장되고 쿠키는 Text형태로 저장된다. ,https://junhyunny.github.io/information/cookie-and-session/,
15,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키의 만료시점은 쿠키 저장시 설정하기 때문에 브라우저가 종료되도, 만료시점이 지나지 않으면 자동 삭제되지 않습니다. 그러나 세션은 브라우저 종료시 삭제된다. 그리고 보안의 측면에서 세션은 서버가 관리하기 때문에 보안성이 쿠키보다 좋다. 쿠키는 클라이언트가 관리하기 때문에 해킹에 취약하다. ",https://junhyunny.github.io/information/cookie-and-session/,
16,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 쿠키는 클라이언트 로컬에 저장되기 때문에 변질되거나 request에서 스니핑 당할 우려가 있어서 보안에 취약하지만 세션은 쿠키를 이용해서 sessionid만 저장하고 그것으로 구분해서 서버에서 처리하기 때문에 비교적 보안성이 좋습니다. ",https://junhyunny.github.io/information/cookie-and-session/,
17,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"가장 큰 차이점은 사용자의 정보가 저장되는 위치입니다. 때문에 쿠키는 서버의 자원을 전혀 사용하지 않으며, 세션은 서버의 자원을 사용합니다. 보안 면에서 세션이 더 우수하며, 요청 속도는 쿠키가 세션보다 더 빠릅니다.  ",https://junhyunny.github.io/information/cookie-and-session/,
18,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 클라이언트(브라우저)에 메모리 또는 파일에 저장하고, 세션은 서버 메모리에 저장된다. 쿠키는 파일로 저장되는 경우 탈취, 변조될 위험이 있고, Request/Response에서 스나이핑 당할 위험이 있어 보안이 비교적 취약하다. 반대로 Session은 클라이언트 정보 자체가 서버에 저장되어 있으므로 비교적 안전하다. ",https://jeong-pro.tistory.com/80,
19,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키는 지속 쿠키의 경우에 브라우저를 종료하더라도 저장되어 있을 수 있는 반면에 세션은 서버에서 만료시간 / 날짜를 정해서 지워버릴 수 있기도 하고 세션 쿠키에 세션 아이디를 정한 경우, 브라우저 종료시 세션아이디가 날아갈 수 있다. ",https://jeong-pro.tistory.com/80,
20,mstr_nw_1,jack,"저장위치 - 2점, 보안 - 1점, Lifecycle - 1점, 속도 - 1점","저장위치가 쿠키는 클라이언트측이고, 세션은 웹서버라는 내용 - 2점, 세션이 쿠키보다 속도가 느리다는 내용 - 1점, 세션이 쿠키보다 보안에 유리하다는 내용 - 1점, Lifecycle에 대한 내용 - 1점",[네트워크 1] 쿠키와 세션의 차이점을 설명해주세요.,"쿠키에 정보가 있기 때문에 서버에 요청시 헤더를 바로 참조하면 되므로 속도에서 유리하지만, 세션은 제공받은 세션아이디(Key)를 이용해서 서버에 다시 데이터를 참조해야하므로 속도가 비교적 느릴 수 있다. ",https://jeong-pro.tistory.com/80,
21,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성이란 수학에서 사용하는 용어에서 유래한 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 뜻합니다.
",https://velog.io/@dion/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0,
22,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"서버의 상태는 멱등성이 유지되어야 하는 경우 같은 행위를 여러 번 반복하더라도 같은 효과를 가져야 합니다.
",https://velog.io/@dion/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0,
23,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등한 메서드는 서버의 상태를 변경시킬 수도 있고, 시키지 않을 수도 있습니다. 다만 요청한 사항은 에러가 나거나, 지연이 발생하지 않는 한 요청에 대한 서버의 상태는 항상 같습니다.",:https://velog.io/@dion/HTTP-%EB%A9%94%EC%86%8C%EB%93%9C%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0,
24,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"동일한 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 효과를 가지고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method가 멱등성을 가진다고 한다.",https://velog.io/@gidskql6671/HTTP-Method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1,
25,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,HTTP Method의 멱등성은 요청을 한번 보내는 것과 여러번 연속으로 보내는 것이 같은 효과를 가지는 것 이다. 같은 요청을 했을 때 응답하는 상태코드가 바뀌더라도 서버의 상태가 항상 같은 상태라면 멱등성이 있다고 판단한다.,https://velog.io/@gidskql6671/HTTP-Method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1,
26,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"우리가 흔히 사용하는 HTTP Method는 GET, POST, PUT, PATCH, DELETE가 있다. HTTP 스펙에 명시된 것에 의하면 GET, PUT, DELETE는 멱등성을 가지도록, POST와 PATCH는 멱등성을 가지지 않도록 구현해야 한다. ",https://velog.io/@gidskql6671/HTTP-Method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1,
27,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,HTTP 메서드의 멱등성은 여러번 요청을 보내더라도 서버의 상태가 변하지 않는 것을 말한다. 검정색 물감통에 붓을 찍으면 항상 검정 물감이 찍혀 나오는 것과 같다. HTTP 메서드의 멱등성은 단지 규약일 뿐이라서 꼭 지켜야 하는건 아니지만 규약들을 제대로 지키지 않으면 원치 않는 동작을 야기할 가능성이 크기 때문에 가능한 규약을 지켜 그에 맞는 동작을 하도록 구현하는게 좋다.,https://velog.io/@gidskql6671/HTTP-Method%EC%9D%98-%EB%A9%B1%EB%93%B1%EC%84%B1,
28,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말합니다. 다른 말로는, 멱등성 메서드에는 통계 기록 등을 제외하면 어떠한 부수 효과(side effect)도 존재해서는 안됩니다. 올바르게 구현한 경우 GET, HEAD, PUT, DELETE 메서드는 멱등성을 가지며 POST 메서드는 그렇지 않습니다. 모든 안전한 메서드는 멱등성도 가집니다.", https://developer.mozilla.org/ko/docs/Glossary/Idempotent,
29,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성은 동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고 서버의 상태도 동일하게 남는 것 입니다. 멱등성을 따질 땐 실제 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있습니다. 첫 번째 DELETE 요청이 200을 반환한다면 그 이후에는 아마 404를 반환할 것입니다. 하지만 두 번째 DELETE 요청에서 200이 또 반환된다면 그건 멱등성 규율을 위반한 예시입니다.",https://developer.mozilla.org/ko/docs/Glossary/Idempotent,
30,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성이란 특정 메서드의 요청을 여러번 하더라도 한번 요청했을 때와 결과가 같다면 멱등하다라고고 한다. PUT, DELETE, TRACE 및 GET, HEAD, OPTIONS가 멱등성을 갖는다.",https://sangwoo0727.github.io/network/Network-1_HttpMethod/#%EB%A9%B1%EB%93%B1%EC%84%B1-idempotent,
31,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등법칙또는 멱등성은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로, 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. 정리하자면 특정 HTTP 메서드를 여러 번 요청을 했을 경우, 매번 요청 결과가 같다면 해당 메소드를 멱등성 메서드라고 한다.",https://atoz-developer.tistory.com/117,
32,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성은 어떠한 값에 대해 여러번 동일한 연산을 수행하였을 때, 호출 횟수에 구애받지 않고 동일한 결과값을 내어주는 성질이라고 이해하면 될 것 같다.",https://hudi.blog/http-method-idempotent/,
33,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"동일한 요청을 한번 보내는 것과, 여러번 보내는 것이 서로 동일한 효과를 지니고, 서버의 상태도 동일하게 남을 때 해당 HTTP Method가 멱등성을 갖는다고 이야기한다. 멱등성을 따질 때에는 서버의 상태만 바라보면 되며, HTTP 응답 Status는 신경쓰지 않아도 된다. ",https://hudi.blog/http-method-idempotent/,
34,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. GET 요청 같은 경우 여러 번 호출해도 클라이언트는 동일한 응답을 받는다. 또한 POST는 여러 번 호출할 경우 여러 열이 추가된다.,https://lnk7424.tistory.com/7,
35,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다. 멱등성이 성립하는 메소드는 통계 기록을 제외하면 어떠한 side effect도 존재해서는 안된다. ",https://lnk7424.tistory.com/7,
36,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성은 같은 행위를 여러번 수행해도 결과가 같다는 것을 의미한다. 멱등성을 따질 때에는 서버의 백엔드 상태만 보면 되며, 각 요청에서 반환하는 응답 코드는 다를 수 있다. ",https://lnk7424.tistory.com/7,
37,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"멱등성이란 어떤 대상에 같은 연산을 여러번 적용해도 결과가 달라지지 않는 성질이다. 예를 들어 어떠한 수에 1을 곱하는 x = x * 1과 같은 함수는 어떠한 값에 1번을 적용하던, 1000번을 적용하던 항상 x를 반환한다. 이런 연산을 멱등성이 보장된다고 한다.",https://lnk7424.tistory.com/7,
38,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"HTTP 메소드 또한 결국 어떤 자원을 쓰고 읽고 수정하고 지우는 CRUD의 의미를 가지기 때문에, 우리는 어떤 행위가 멱등성을 보장하고 어떤 행위가 멱등성을 보장하지 않는지 알고 있어야 어플리케이션이 예상하지 못한 방향으로 동작하는 것을 방지할 수 있다.
",https://lnk7424.tistory.com/7,
39,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,같은 연산을 여러번 반복하더라도 결과가 달라지지 않는 성질이 멱등성인데 HTTP 요청 같이 통신 회선상에서 일어나는 사건에서도 멱등성은 중요한 개념이다. 오류가 발생했을 경우 서버에서 멱등성을 보장하지 않는다면 재시도를 하지 않아야 한다.,https://shanta.tistory.com/7,
40,mstr_nw_2,jack,"stateless - 2점, 동일한 요청 - 2점, POST - 1점","서버가 상태를 갖지 않는다는 내용 - 2점, 같은 동작을 여러번 해도 결과가 바뀌지 않는다는 내용 - 2점, HTTP method 중에는 GET, PUT, DELETE 등이 있음, 혹은 멱등성이 아닌 메서드 POST, PUT에 대한 내용 - 1점",[네트워크 2] HTTP 메서드의 멱등성에 대해서 설명해주세요.,"연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질을 멱등성(idempotence)이라 한다. Rest api의 경우 get, head, put, delete 메소드는 멱등성을 가지고 있다. 그러나 post는 상태를 변화시키기 때문에 멱등성이 없다. (Status 변화를 준다.)",https://shanta.tistory.com/7,
41,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"같은 타입의 데이터를 나열한 선형 자료구조이며, 연속된 메모리 공간에 순차적으로 저장한다. 또한 크기가 고정되어 있고, 선언 시 배열의 크기를 정하고 이를 변경할 수 없다.",https://devjun.tistory.com/88,
42,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"고정된 크기를 갖는 같은 자료형의 원소들이 연속적인(논리적 저장 순서와 물리적 저장 순서가 일치) 형태로 구성된 자료구조. 인덱스에 따라 값을 유지하므로 원소가 삭제되어도 빈자리가 남게되어 메모리가 낭비된다. 처음 크기를 10으로 지정한다면 5개의 데이터만 저장하더라도 실제 배열의 크기는 10이다. 고정이고 연속적인 만큼 인덱스로 random access가 가능하다. 접근, 수정 O(1)으로 빠르게 조회가 가능하다.",https://jy-tblog.tistory.com/38 ,
43,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"배열은 같은 타입의 데이터를 여러개 나열한 선형 자료구조로, 연속적인 메모리 공간에 순차적으로 데이터를 저장한다. 배열은 선언할 때 크기를 정하면, 그 크기로 고정이 된다. 선언된 값은 다시 배열을 선언하지 않으면 변경할 수 없다. 배열의 주소를 살펴보면, 한 칸마다 배열의 자료형의 크기를 가지고 있다.",https://chunggaeguri.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4Array%EC%9D%B4%EB%9E%80,
44,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,배열은 실제 메모리 상에도 메모리가 순차적으로 저장된다. 따라서 어느 위치에 있는지 인덱스로 손쉽게 접근할수 있는 것이다. 배열은 인덱스를 사용해서 무작위 접근(random access)가 가능하여 검색 성능이 빠르다. 순차 접근(sequential access)이 연결리스트보다 빠르다.,https://cocodding0723.github.io/datastructure/02_array-post/,
45,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,같은 자료형을 가진 변수를 하나로 나타낸 것이다. 연속된 메모리 공간으로 이루어져있다. 정적 표현이다. 인덱스를 이용하여 표현한다. 지역성을 갖고 있다.,https://undeadkwandoll.tistory.com/38,
46,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,여러 데이터를 하나의 이름으로 그룹핑해서 관리 하기 위한 자료구조. index와 값의 쌍으로 구성 index는 값에 대한 unique한 id와 같은 역할이자 Array에서는 순서를 나타냄. 논리적 저장 순서와 물리적 저장 순서가 일치하기 때문에 index로 해당 원소에 접근할 수 있다. (O(1)) 연속된 메모리의 공간으로 이루어져 있다. 배열은 정의와 동시에 길이를 지정하며 길이를 바꿀 수 없다.,https://github.com/SogangSpring/NewCSStudy/blob/main/07%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%84%B1%EC%9D%BC.md,
47,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"데이터 여러개를 순차적으로 나열한 자료구조이다.
연속적인 메모리 공간에 순차적으로 나열했다.
선언한 이후에 크기는 고정이다. random access 에 매우 강하다. 시간 복잡도가 1이다.
구현이 쉽다.",https://github.com/SogangSpring/NewCSStudy/blob/main/07%EC%A3%BC%EC%B0%A8/%EA%B9%80%ED%98%84%EC%9A%B0.md,
48,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"배열은 메모리상에 순서대로 데이터를 저장합니다. 배열은 데이터를 인덱스로 조회할 수 있기 때문에 인덱스 조회성능이 높고, 데이터가 메모리에 순서대로 저장되어 있기 때문에, 캐시의 지역성으로 인하여 비교적 빠르게 탐색을 수행할 수 있습니다.",https://github.com/ksundong/backend-interview-question,
49,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"연관된 데이터를 연속적인 형태로 구성된 구조인 자료구조. 자바스크립트 배열의 길이는 언제든 늘어나거나 줄어들 수 있고, 연속적이지 않게 저장할 수 있어 밀집성을 보장하지 않는다. 인덱스를 통해 요소에 접근할 수 있고 반드시 정수로만 접근할 수 있다. 대괄호 구문이나 속성 접근자를 사용할 경우 배열의 요소가 아니라 Array 객체에 연결된 변수를 참조한다. 원하는 원소의 index를 알고 있다면 O(1)로 원소를 찾을 수 있다.",https://velog.io/@apparatus1/%EB%B0%B0%EC%97%B4Array%EA%B3%BC-%EB%A7%81%ED%81%AC%EB%93%9C%EB%A6%AC%EC%8A%A4%ED%8A%B8Linked-List%EC%9D%98-%ED%8A%B9%EC%A7%95,
50,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"연속된 메모리의 공간에 순차적으로 데이터를 저장하는 선형 자료구조이다.
크기가 고정적이고 공간이 낭비되거나 재할당이 필요할 수 있다. 자바스크립트 처럼 대부분의 스크립트 언어는 배열의 크기를 동적으로 변경할 수 있다.
논리적인 저장 순서와 물리적(메모리) 저장 순서가 일치한다. 인덱스를 사용해 특정 원소에 접근이 가능하다.(Random Access ) 메모리는 배열이 선언될 때(컴파일 할 때) Stack영역에 할당한다. 시간복잡도는 O(1)이다.",https://velog.io/@codenmh0822/%EC%84%A0%ED%98%95-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4Array,
51,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"연관된 데이터를 하나의 변수에 그룹핑해서 관리하기 위한 선형 자료구조로
배열을 이용하면 하나의 변수에 여러 정보를 담을 수 있으며,
반복문과 결합하여 효율적으로 데이터를 처리할 수 있다.
주로 데이터의 개수가 정해져 있는 경우나 데이터의 수정이 적은 경우,
혹은 데이터의 검색이 빈번한 경우에 사용하는 선형 자료구조형이다.
배열의 특징으로는 배열안의 데이터들은 같은 자료형으로 나열되있다는 것,
그리고 데이터가 연속된 메모리 공간에 순차적으로 저장 된다는 것,
그래서 배열의 논리적 순서(인덱스)와 원소값의 물리적인 순서(메모리 주소)
두가지가 동일하다는 것 등을 꼽을 수 있다.
원소가 키와 값으로 이루어져 탐색 시간은 O(1)이다.",https://bigsong.tistory.com/31,
52,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"여러 데이터를 하나의 이름으로 그룹핑해서 관리하는 자료구조(하나의 변수에 여러 데이터). 보통 반복문과 결합하여 많은 정보를 효율적으로 처리한다. 배열의 인덱스를 이용하여 값을 식별할 수 있으며, 크기가 고정되어있다.",https://saem-ee.tistory.com/8,
53,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,논리적 저장 순서와 물리적 저장 순서가 일치하는 자료구조. 따라서 인덱스(Index)로 해당 원소에 접근할 수 있으며 Random Access가 가능합니다. 하지만 삽입/삭제 시 해당 원소에 접근하여 작업을 완료한 후 빈 공간이 생기지 않도록 shift 해줘야 하므로 O(N)의 시간이 소요됩니다.,https://cocoon1787.tistory.com/705,
54,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"동일한 자료형의 데이터를 한꺼번에 관리하기 위한 자료구조로 하나의 변수에 여러 데이터를 담을 수 있으며, 반복문을 통해 효율적인 처리가 가능하다. 크기가 정해져있어 바꾸지 못한다는 단점이 있지만, 인덱스를 통해 데이터를 빠르게 조회할 수 있다는 장점이 있다.",https://soobarkbar.tistory.com/48,
55,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,같은 타입의 데이터를 나열한 선형 자료구조이다. 연속된 메모리공간에 순차적으로 저장하며 처음 배열을 선언할때의  크기로 고정이되며 한번 지정된 크기는 줄일수도 늘릴수도없다. 인덱스를 가지고 있어 바로 접근이 가능하다. 연속된 메모리공간에 존재하기 때문에 관리가 편하다.,https://blue-ilike.tistory.com/entry/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90%EB%8C%80%ED%95%B4-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0,
56,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,변수에는 값을 하나 저장할 수 있는데 이런 식으로는 대량의 데이터를 처리하는데 불편합니다. 그래서 거의 모든 언어에서 배열(Array) 자료형을 제공하고 있습니다. 배열에서는 하나의 변수에 여러개의 값을 분리해서 저장할 수 있습니다. 배열의 기본적 아이디어는 같은 데이터 타입을 연속적으로 순서가 있도록 나열하는 것 입니다. ,https://smoothiecoding.kr/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%B0%EC%97%B4/,
57,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"배열은 자료구조에서 가장 일반적인 구조로 메모리상에 형식이 같은 자료 여러 개가 모여 새로운 하나를 이룬 형식이다. 배열은 여러 값을 저장하기 위해 메모리의 연속적인 공간을 차지하고 있다. 배열요소의 인덱스는 0에서부터 전체 요소의 개수보다 1 작은 범위까지이다. 즉, 데이터가 있는 위치(인덱스)만 알고 있다면 바로 해당 메모리에 접근이 가능하다.",https://noapps-code.tistory.com/124,
58,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"배열은 같은 타입의 데이터를 연속적으로 저장한 자료구조입니다. 배열의 특징은 '정적'이라는 점과 '연속적'이라는 것이죠. 정적이라는 말은 처음 배열의 크기가 정해지면 크기를 변경할 수 없음을 뜻합니다. 연속적이라는 건 메모리 상에서 배열의 첫번째 요소는 두번째 요소와 연이어 붙어있다는 것을 말합니다. 즉, 모든 요소들이 저장된 위치는 연속적으로 붙어있습니다.",https://93jpark.tistory.com/123?category=1021186,
59,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"연관된 데이터를 하나로 묶어 그루핑해서 관리하기 위해 만들어진 자료구조
배열에서 위치를 가리키는 숫자를 인덱스(Index)라고 부름. 인덱스는 0 부터 시작한다. 참조 객체이며, 배열을 가리키는 참조 변수는 스택(Stack) 영역에 할당된다. 참조 변수가 가리키고 있는 주소값(Address)는 힙(heap)영역에 생성되는 배열의 주소값이다. 인덱스를 통한 접근이 가능하므로 원소를 조회 및 수정할 때 시간복잡도는 O(1)이다.",https://epser.tistory.com/29,
60,mstr_ds_1,kshired,"저장 순서 - 2점, 시간 복잡도 - 1점, 랜덤 액세스 -2점","논리적 저장 순서와 물리적 저장 순서가 일치한다., 인덱스(index)로 해당 원소(element)에 접근할 수 있다., O(1)에 random access가 가능하다.",[자료구조 1] Array의 특징을 설명해주세요.,"동일한 자료형을 연속적인 메모리 공간에 저장한 자료구조로, 인덱스(index)를 사용하여 임의 접근(Random Access)이 가능하다. 각 항목이 동일한 자료형이므로 동일한 크기를 갖는다. 저장 공간의 크기가 고정적이다. 원소 접근하는데 걸리는 시간이 상수 시간 O(1)이다.",https://gamedevlog.tistory.com/7,
61,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"한 쪽 끝에서만 자료를 넣고 뺄 수 있는 LIFO(Last In First Out) 형식의 자료 구조. 즉, 가장 최근에 스택에 추가한 항목이 가장 먼저 제거될 항목이다. 
",https://github.com/WeareSoft/tech-interview/blob/master/contents/datastructure.md#stack,
62,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"후입선출(Last In First Out, LIFO) 의 형태를 가진 자료구조로, 데이터의 개수가 스택의 크기를 초과하면 overflow가 일어나고, 아무것도 없을 때 pop을 하거나 데이터에 접근시 underflow가 일어나기 때문에 구현시 예외처리가 필수적이다.",https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%84%B1%EC%9D%BC.md,
63,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"LIFO 구조로, 가장 상위에 위치하는 자료는 최근에 들어온 자료입니다. 자료를 삭제하는 연산은 pop 연산으로 가장 최근에 들어온 자료가 삭제 됩니다.",https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%EA%B9%80%ED%98%84%EC%9A%B0.md,
64,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"삽입, 삭제 연산이 한 방향에서 이루어지는 선형 자료구조로, 한 방향에서 삽입과 삭제가 이루어지기 때문에 나중에 삽입된 데이터가 먼저 삭제되는 후입선출(LIFO, Last In First Out) 구조를 가진다. 스택에 데이터가 삽입될 위치를 Top이라고 한다. 비어있는 스택에서 원소를 추출하려고 할 때 stack underflow가 발생하고, 스택이 넘치는 경우를 stack overflow라고 한다.",https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%ED%95%A8%ED%9D%AC%EC%9B%90.md,
65,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을수 있고,
top으로 정한 곳을 통해서만 접근할 수 있다.
top에는 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며,
삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.
스택에서 자료를 삭제할 때도 top을 통해서만 가능하다. 스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다. 이러한 스택의 구조를 후입선출(LIFO, Last-In-First-Out) 구조이라고 한다.",https://devuna.tistory.com/22,
66,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택은 위의 그림과 같이 아래에서 위로 쌓이는 형식이며 가장 최근에 들어온 자료를 top이라고 부릅니다. 가장 위쪽(최신)의 데이터부터 꺼낼 수 있으며 이러한 스택의 구조를 후입선출(LIFO, Last In First Out)의 구조라고 합니다. 즉, 스택의 경우 자료의 삽입과 삭제는 한 곳(top)에서만 이루어지게 됩니다.",https://cocoon1787.tistory.com/691,
67,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,가장 최근에 보관한 자료를 먼저 꺼내는 LIFO(Last In First Out)방식의 자료 구조이다. 리스트의 한쪽으로 삽입과 삭제 연산을 수행한다.,https://ehpub.co.kr/tag/%EC%8A%A4%ED%83%9D%EC%9D%98-%ED%8A%B9%EC%A7%95/,
68,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,선형 자료구조로 LIFO(Last-In-First-Out)라는 특징을 가지고 있다. push와 pop은 오직 모두 stack의 top인 구조의 끝에서 동작한다.,https://velog.io/@junhok82/Stack,
69,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택은 위의 사진처럼 같은 구조와 크기의 자료를 정해진 방향으로만 쌓을 수 있고,
top으로 정한 곳을 통해서만 접근할 수 있다.
가장 위에 있는 자료(top)는 가장 최근에 들어온 자료를 가리키고 있으며,
삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.
스택에서 자료를 삭제할 때도 top을 통해서만 가능하다.
스택에서 top을 통해 삽입하는 연산을 'push' , top을 통한 삭제하는 연산을 'pop'이라고 한다.
 
따라서 스택은 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다는 구조적 특징을 갖게 된다.
이러한 스택 구조를 후입선출(LIFO, Last-In-First-Out) 구조라 한다.
",https://dev-coco.tistory.com/16,
70,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택(Stack)은 LIFO(Last-In-First-Out, 후입선출)의 특징을 가진 자료구조이다. LIFO란, 가장 먼저들어온 것이 가장 늦게나가는 방식이다. 위와 같이, 1,2,3순서대로 들어갔지만, 나올때는 3,2,1순서로 나오는 것을 LIFO방식이라고하고, 스택은 이러한 LIFO방식을 사용하는 자료구조이다. 즉, 스택에 가장 나중에 들어온 자료가 가장 먼저 삭제된다.",https://currygamedev.tistory.com/17,
71,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"그릇 더미들을 쌓을 때에는 아래쪽에서부터 하나씩 쌓아올리고, 해당 그릇 더미들에거 하나의 그릇만 꺼내려고 한다면 가장 위쪽에 있는 거 부터 차례로 꺼낼 수 있을 것입니다. 이러한 맥락에서 스택 자료구조는 후입선출(Last-In-Fist-Out) 의 특징을 가지고 있습니다. 후입선출은 말 그대로 가장 나중에 들어간 것이 가장 먼저 나간다는 의미입니다.",https://ai-rtistic.com/2022/01/15/data-structure-stack/,
72,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택은 자료형의 값을 하나의 방향으로만 쌓을 수 있고, top으로 정한 곳을 통해서만 접근할 수 있다. 가장 위에 있는 자료는 가장 최근에 들어온 자료를 가리키고 있으며,  삽입되는 새 자료는 top이 가리키는 자료의 위에 쌓이게 된다.  스택은 시간 순서에 따라 자료가 쌓여서 가장 마지막에 삽입된 자료가 가장 먼저 삭제된다는 구조적 특징을 가지게 된다. 이러한 스택의 구조를 후입선출(LIFO, Last-In-First-Out)구조라고 한다.",https://yang-droid.tistory.com/42,
73,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택이란 가장 마지막에 넣은 자료가 가장 먼저 나오는 특징(LIFO: last in first out)을 가진 자료구조이다. 스택은 탑(top)이라 하는 한쪽 끝에서 모든 삽입(push)과 삭제(pop)가 이루어진다. 쌓아 올린 동전을 생각하면 이해가 쉽다. 무너지지 않은 채, 동전을 쌓거나 내리려면 제일 윗 부분에서 작업을 해야 한다.",https://cloudstudying.kr/lectures/141,
74,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"자료구조(Data Structure)의 한 종류로 후입선출(LIFO : List in First out)구조를 가지고 있다.
따라서 가장 먼저 들어간 데이터가 가장 끝부분에 위치하게 되는 구조이다.
이러한 특징으로 데이터 저장과 같은 기능에는 적합하나, 실시간 처리를 요구하는 구조에서는 부적합한 자료구조이다.",http://www.incodom.kr/%EC%8A%A4%ED%83%9D,
75,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"모든 원소의 삽입과 삭제가 top이라는 자료구조의 한 쪽 끝에서만 수행되는 제한된 리스트 구조이다. 후입 선출 (Last-In-First-Out, LIFO) 방식
으로, 가장 마지막에 입력된 자료가 가장 먼저 출력된다.",http://compiler.sangji.ac.kr/lecture/ds/2011/lecture04_stack&Queue.pdf,
76,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"데이터를 제한적으로 접근할 수 있는 구조이다.
가장 나중에 쌓은 데이터를 가장 먼저 빼낼 수 있는 데이터 구조. 즉, 한쪽 끝에서만 자료를 넣거나 뺼 수 있으며 앞선 시간에 살펴본 Queue 와는 반대로 LIFO (Last In First Out) 정책을 사용합니다.
대표적으로 재귀 함수에서 사용 되는 구조 입니다.
 ",https://bloowhale.tistory.com/5,
77,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택의 데이터는 스택의 끝에만 삽입, 삭제, 조회가 가능하다. 스택 연산을 묘사하는 데 사용되는 두문자는 LIFO(last in, first out)이다. 스택은 입력 받은 순서와 반대로 데이터를 처리해야 할 때(LIFO) 항상 이상적이다. 워드 프로세서의 ""되돌리기"" 함수나 네트워크 애플리케이션에 쓰이는 함수 호출 등에서 스택이 유용할 것이다. ",https://stormpy.tistory.com/216,
78,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택(Stack)은 쌓다, 쌓이다, 포개지다 와 같은 뜻을 가지고 있다. Stack은 직역 그대로, 데이터(data)를 순서대로 쌓는 자료구조이다.
 입력과 출력이 하나의 방향으로 이루어져 접근이 제한적이다.
이러한 Stack 자료구조의 정책을 LIFO(Last In First Out) 혹은 FILO(First In Last Out)이라고 부르기도 한다",https://hanamon.kr/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EC%8A%A4%ED%83%9D/,
79,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"Stack은 사전적 의미로 쌓다, 포개다, 채우다를 의미합니다. 자료구조 개념의 하나인 Stack은 바로 쌓아 올리는 개념입니다. 보통 Stack의 특징이라고 하면 후입 선출의 또는 LIFO의 개념이라고 말합니다. 

후입 선출, List In First Out(LIFO)은 결국 어떠한 일이 계속 쌓이면 마지막에 있는 일부터 처리를 하는 개념입니다.",https://blog-of-gon.tistory.com/100,
80,mstr_ds_2,kshired,"LIFO - 2점, 삽입 - 1점, 삭제 - 1점, DFS - 1점","Last In First Out  - 2점 , 자료의 삽입과 삭제가 한 곳에서만 이루어짐 - 1점 , 삽입, 삭제, 조회의 시간 복잡도가 O(1) - 1점, DFS에서 사용 됨 - 1점 ",[자료구조 2] Stack의 특징을 설명해주세요.,"스택(Stack)이란 자료구조는 선입후출(First In, Last Out: FILO), 후입선출(Last In, First Out: LIFO)의 구조를 가지고 있습니다. 스택의 특징으로는, 한 방향 끝에서만 데이터의 삽입과 제거가 이루어진다는 것입니다.",https://blog.hexabrain.net/210,
81,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 할당 받은 자원을 이용하는 실행 단위이다.,https://suzyalrahala.tistory.com/53,
82,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 코드의 집합으로 이루어진 프로그램이 실행되는 것이고 스레드는 실행되는 프로그램의 작업 단위를 뜻하며 여러개의 스레드가 생겨날 수 있다.,https://suzyalrahala.tistory.com/53,
83,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 운영체제로부터 자원을 할당받는 작업의 단위이고 스레드는 경량화된 프로세스라고 볼 수 있다.,https://suzyalrahala.tistory.com/53,
84,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 프로그램의 단위이고 스레드는 작업의 단위이며 프로세스를 할당할 때 메모리의 스택, 힙, 코드, 데이터 영역을 전부 할당하지만 스레드는 프로세스의 힙, 데이터, 코드영역을 공유하기 때문에 각 스레드에 스택만 따로 할당된다.",https://suzyalrahala.tistory.com/53,
85,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 프로그램의 단위이고 스레드는 작업의 단위이며 프로세스를 할당할 때 메모리의 스택, 힙, 코드, 데이터 영역을 전부 할당하지만 스레드는 프로세스의 자원을 공유하기 때문에 스택영역만 할당된다.",https://suzyalrahala.tistory.com/53,
86,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 단순하게 말하면 일을 처리하는 일련의 과정을 말합니다. 그리고 스레드는 한 프로세스 내에서 동작되는 여러 실행의 흐름입니다. 프로세스 하나에 자원을 공유하면서 일련의 과정을 여러 개를 동시에 실행시킬 수 있는 것을 말합니다.,https://devuna.tistory.com/21,
87,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 프로그램 단위로 실행되며 모든 영역을 할당받습니다. 하지만 스레드는 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유합니다. 기본적으로 하나의 프로세스가 생성되면 하나의 스레드가 같이 생성되며 이는 메인스레드라고 불립니다.,https://devuna.tistory.com/21,
88,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 운영체제로부터 시스템 자원을 할당받는 작업의 단위이고 스레드는 한 프로세서 내의 주소 공간이나 자원들을 대부분 공유한다. (힙, 데이터, 코드영역)",https://devuna.tistory.com/21,
89,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스란 메모리에 올라와 실행되고 있는 프로그램의 인스턴트를 말합니다. 그리고 스레드란 한 프로세스 내에서 동작되는 작업 단위로 분류합니다,https://devuna.tistory.com/21,
90,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 컴퓨터에서 연속적으로 실행되고 있는 프로그램이고 스레드는 프로세스 내에서 실행되는 여러 흐름의 단위입니다.,https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
91,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 메모리에 로드되어 실행되고 있는 프로그램의 인스턴스 입니다. 그리고 스레드는 프로세스 내에서 실행되는 여러 흐름 단위 입니다.,https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
92,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,운영체제로부터 시스템 자원을 할당받고 운영체제가 관리하는 단위가 프로세스 이고 프로세스가 할당받은 자원을 이용하는 실행 단위가 스레드입니다.,https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
93,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세서(처리기, CPU)에 의해 처리되는 프로그램이 프로세스이고 스레드는 프로세스의 특정 실행 단위이다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
94,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 운영체제로부터 자원을 할당받아 실행, 스레드는 프로세스로부터 자원을 할당받아 실행",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
95,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"하나의 프로세스안에 여러 스레드 생성이 가능하며, 각 스레드는 개별 스택을 가지고 프로세스의 전역 메모리 공간을 공유하며 프로그램을 실행합니다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
96,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 독립된 메모리 영역을 할당받는다. Stack, Code, Data, Heap 영역을 전부 할당 받는다. 그리고 각 프로세스는 다른 프로세스의 할당된 메모리공간에 접근할 수 없으며, 접근이 필요한경우 IPC를 사용하게 된다.
스레드는 프로세스 내에서 각각 별도의 레지스터와 Stack을 할당 받으며. Code, Data, Heap영역을 공유한다. 따라서 IPC와 같은 별도의 기법없이도 쓰레드간 데이터를 손쉽게 주고 받을 수 있게된다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
97,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 독립된 메모리 영역을 할당받는다. Stack, Code, Data, Heap 영역을 전부 할당 받는다. 스레드는 프로세스 내에서 각각 별도의 레지스터와 Stack을 할당 받으며. Code, Data, Heap영역을 공유한다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
98,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,프로세스는 자원을 공유하지 않지만 스레드는 자원을 공유한다.,https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
99,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 메모리에 적재되고 CPU자원을 할당받아 프로그램이 실행되고 있는 상태이고 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
100,mstr_os_2,jack,"프로그램 - 2점, 작업단위 - 1점, Stack - 2점","프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위라는 내용 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위라는 내용 - 1점, 스레드는 프로세스 내에 존재한다는 내용 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받는다는 내용 - 2점, 프로세스는 운영체제로부터 시스템 자원을 할당(프로그램)받는 작업의 단위 - 1점, 스레드는 할당받은 자원을 이용(task)하는 실행의 단위 - 1점, 스레드는 프로세스 내에 존재 - 1점, 스레드는 프로세스의 Code, Data, Heap 영역을 공유받음 - 2점",[운영체제 2] 프로세스와 스레드의 차이점을 설명해주세요.,"프로세스는 메모리에 적재되고 CPU자원을 할당받아 프로그램이 실행되고 있는 상태이다. 그리고 스레드는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 흐름의 단위를 말한다.
프로세스는 할당받을 때 모든 영역을 할당받지만 스레드는 프로세스 내에 있기 때문에 공유된 자원을 사용하고 스택만 독립적으로 할당받아 사용하게 된다.",https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%E2%9A%94%EF%B8%8F-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%B0%A8%EC%9D%B4#%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_VS_%EC%8A%A4%EB%A0%88%EB%93%9C_%EA%B2%B0%EB%A1%A0,
101,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"화장실에서 줄서서 기다리고 처리하는 형태의 자료구조로 한 방향에서는 삽입연산이, 반대편에서는 삭제연산이 이루어지는 자료구조이다. 스택과 마찬가지로 선형 자료구조이다. 한쪽 방향에서 삽입이, 반대편에서 삭제가 이루어지기 때문에 먼저 삽입된 데이터가 먼저 삭제되는 선입선출(FIFO) 구조를 가진다. 너비 우선 탐색(BFS) 구현에  사용된다.",https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%ED%95%A8%ED%9D%AC%EC%9B%90.md,
102,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,FIFO 자료구조. 자료를 추가 할 때는 PUSH 연산으로 QUEUE의 맨뒤의 자료를 추가한다. 자료를 제거 할 때는 POP 연산으로 QUEUE의 맨앞의 자료를 제거한다.,https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%EA%B9%80%ED%98%84%EC%9A%B0.md,
103,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"선입선출(First In First Out, FIFO)의 형태를 가지고 있는 자료구조이다.
먼저 온 것이 먼저 나가는 특성을 가지는 것이, 줄을 서서 기다릴 때 먼저 온 사람이 먼저 들어가는 것과 같은 이치이다. ",https://github.com/SogangSpring/NewCSStudy/blob/main/08%EC%A3%BC%EC%B0%A8/%EA%B9%80%EC%84%B1%EC%9D%BC.md,
104,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"컴퓨터의 기본적인 자료 구조의 한가지로, 먼저 집어 넣은 데이터가 먼저 나오는 FIFO(First In First Out)구조로 저장하는 형식. 데이터가 입력된 시간 순서대로 처리해야 할 필요가 있는 상황에 이용한다. 대표적으로 너비 우선 탐색(BFS) 구현에 사용된다.",https://github.com/WeareSoft/tech-interview/blob/master/contents/datastructure.md#stack,
105,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"정해진 곳(top)에서만 자료의 삽입과 삭제가 이루어지는 스택과는 다르게 큐는 Rear부분에서 자료의 삽입이, Front부분에서 자료의 삭제가 이루어집니다. 큐는 선입선출(FIFO, First In First Out)의 자료구조를 가집니다. 활용 예시로는 너비 우선 탐색 (BFS) 알고리즘이 있습니다.",https://cocoon1787.tistory.com/691,
106,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐(Queue)는 한쪽 끝에서만 삽입이 이루어지고, 다른 한쪽 끝에서는 삭제 연산만 이루어지는 유한 순서 리스트이다. First in First Out (FIFO) 선입선출이라고 생각하면 쉽습니다. 먼저들어온것이 먼저 나가는 형식입니다. 즉, 제일 처음에 들어온 데이터가 먼저 삭제가 된다.",https://donggu1105.tistory.com/163,
107,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐(queue)는 차례를 기다리는 줄이라는 의미를 가지고 있는 단어처럼 먼저 들어온 자료부터 순서대로 처리하는 방식을 말한다. 한 쪽 끝에서는 자료의 삽입 연산만 가능하고 반대쪽 끝에서는 삭제만 가능한 구조로서 선입선출(FIFO : First In First Out)의 특징을 가진다. 앞(front)에서는 삭제만 일어나고, 뒤(rear)에서는 삽입만 일어난다.",https://velog.io/@suitepotato/00004,
108,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"가장 먼저 보관한 자료를 먼저 꺼내는 FIFO(First In First Out) 방식의 자료구조.
한쪽으로 보관하고 다른 쪽에서 꺼냄. 대기 순서에 따라 처리하는 연산에 사용된다.",https://ehpub.co.kr/tag/%ED%81%90%EC%9D%98-%ED%8A%B9%EC%A7%95/,
109,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"자료의 입력과 출력을 한 쪽 끝(front, rear)으로 제한한 자료구조.FIFO(First In First Out)구조 put(), get()컴퓨터 버퍼에서 주로 사용, 마구 입력이 되었으나 처리를 하지 못할 때, 버퍼(큐)를 만들어 대기 시킨다.",https://jeong-pro.tistory.com/97,
110,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"한쪽 끝에서 삽입되고, 다른 한쪽 끝으로 삭제되는 리스트 구조의 일종임. 데이터의 입력,출력이 정해진 위치에서 만 가능. FIFO 규칙을 따른다.",http://www.ktword.co.kr/test/view/view.php?m_temp1=443,
111,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"번호표 순서대로 먼저 온 고객부터 처리해 주는 것과 같이 선입선출 형태의 구조를 큐(Queue)라고 부릅니다. 큐는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 자료구조이지만 한쪽 끝에서는 삽입 작업이 이루어지고 반대쪽 끝에서는 삭제 작업이 이루어지는 자료구조입니다. 데이터가 삽입된 순서대로 삭제되는 선입선출(FIFO, First-In-First-Out)  구조입니다.",https://leejinseop.tistory.com/m/36,
112,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐(Queue) 는 ""줄을 서서 기다린다.""라는 사전적 의미를 가지고 있다.
따라서, 큐 (Queue) 자료구조는, 먼저 들어온게 먼저 나가는 선입선출(FIFO, First In FirstOut) 방식의 자료구조이다. 큐는 주로, 데이터가 입력된 순서에 따라 처리되어야 할 때 사용되며 BFS 구현에 사용된다.",https://wooono.tistory.com/395,
113,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐(Queue)는 FIFO(First In First Out) 의 특징을 갖는 자료구조이다. 입력 데이터들의 순서를 정하는데 최적화 되어있다.
가장 기본적으로 FIFO를 지원하지만, 특정 상태에 따라 우선순위를 결정하기도 한다. (= 우선순위 큐)",https://cloudstudying.kr/lectures/142,
114,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,큐(Queue)는 스택(Stack)과 반대로 '선입선출 FIFO(First In First Out)' 의 구조를 가지고 있습니다. 말 그대로 먼저 들어온 것이 먼저 나가는 구조이기 때문에 데이터를 추가한 순서대로 제거할 수 있기 떄문에 스트리밍 등 소프트웨어 개발에서 응용되고 있습니다.,https://devmoony.tistory.com/91,
115,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐는 선입선출(First-in First-out)의 구조를 가지고 있습니다. 앞자를 따서 FIFO 구조라고 하며, 먼저 들어온 것이 먼저 나간다라는 뜻입니다. 공연장에서 입장을 기다리는 관객들을 예시로 들 수 있습니다. 큐는 입력된 순서대로 작업을 수행해야 할 때 활용할 수 있습니다.",https://brightwon.tistory.com/8,
116,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"선입선출(First In First Out; FIFO)의 자료구조. 대기열이라고도 한다.  Queue라는 단어 자체가 표 같은 것을 구매하기 위해 줄서는 것을 의미한다.
데이터가 들어오는 위치는 가장 뒤(Rear 또는 Back이라고 한다.)에 있고, 데이터가 나가는 위치는 가장 앞(Front라고 한다.)에 있어서, 먼저 들어오는 데이터가 먼저 나가게 된다. ",https://namu.wiki/w/%ED%81%90(%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0),
117,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"1. 먼저 들어간 데이터가 먼저 나오는 선입선출, FIFO(First In First Out) 구조로, 줄을 서서 기다리는 구조와 같다.
2. 한 쪽 끝은 프런트(front)로 정하여 삭제 연산만 수행한다.
3. 한 쪽 끝은 리어(rear)로 정하여 삽입 연산만 수행한다.
4. 그래프(Graph)의 넓이 우선 탐색(BFS)에 사용된다.",https://haenny.tistory.com/357,
118,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐(Queue) 는 사전적으로 ‘줄서서 기다리다’ , ‘대기행렬’ 이라는 의미를 가지고 있습니다. 큐(Queue) 자료구조는 줄에 기다리는 순서대로 먼저 줄을 선 사람이 먼저 입장하는 구조와 동일하게 이루어져있습니다. 이러한 특징을 선입선출(First-In First-Out) 이라고 표현합니다.",https://ai-rtistic.com/2022/01/22/data-structure-queue/,
119,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,Queue는 대표적인 FIFO 구조이다.즉 FIFO그대로 먼저 넣은데이터가 먼저 빠지는것으로 이해할 수 있다. 즉 데이터를 한쪽으로 넣고 반대쪽으로 데이터가 빠지는 구조로 볼 수 있다. 보통 그래프의 넓이 우선 탐색 ( BFS ) 구현에 사용된다.,https://hofe-rnd.tistory.com/entry/c-STL-Queue-Stack-%EC%A0%95%EB%A6%AC,
120,mstr_ds_3,kshired,"FIFO - 2점, 삽입 - 1점, 삭제 - 1점, BFS - 1점","First In First Out - 2점, rear에서 자료의 삽입이 front에서 자료의 삭제가 이루어짐 - 1점, 삽입, 삭제의 시간 복잡도 O(1), 조회의 시간 복잡도는 O(N) - 1점, BFS에서 사용 됨 - 1점",[자료구조 3] Queue의 특징을 설명해주세요.,"큐 (Queue)는 가장 먼저 삽입된 원소가 가장 먼저 삭제되는 선입선출 (FIFO, First-In First-Out)의 구조이다. 여러 원소들이 한 방향, 한 줄로 늘어선 형태라고 볼 수 있다. 큐에서의 삽입은 큐의 후단에서만 일어나며, 삭제는 큐의 전에서 일어난다. 원소 삽입과 삭제가 같은 쪽에서 일어나는 스택과 달리, 큐는 다른 쪽에서 일어난다",https://piaflu.tistory.com/41,
121,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"원자성, 일관성, 독립성. 지속성. 원자성은 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않거나를 뜻한다.일관성은 트랜잭션 작업 처리의 결과가 항상 일관되어야 한다를 뜻한다. 독립성은 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적임을 의미한다. 지속성은 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 함을 뜻한다. ",https://piaflu.tistory.com/41,
122,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것.
일관성 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것.
독립성 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우, 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어 들수 없다는 점.
지속성 트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야 한다는 점",https://velog.io/@wldus9503/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98Transaction%EB%9E%80,
123,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"ACID는 데이터베이스 트랜젝션이 안전하게 수행된다는 것을 보장하기 위한 트랜잭션의 특징을 말합니다. 원자성 : 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다. 일관성 : 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다. 독립성 : 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. 영속성 : 트랜잭션이 성공적으로 완료 되었으면 결과는 영구적으로 반영되어야 한다.",https://devuna.tistory.com/30,
124,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"ACID, 원자성은 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것. 일관성은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것. 독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점. 지속성은 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점.",https://mommoo.tistory.com/62,
125,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,ACID ; 데이터베이스 트랜잭션이 안전하게 수행되는 것을 보장하기 위한 성질을 가리키는 약어. 원자성 : 실행되다가 중단되지 않는 것을 보장. 일관성 : 일관성 있는 데이터베이스 상태로 유지. 독립성 : 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것. 지속성 : 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미.,https://hyoni-k.tistory.com/55,
126,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,트랜잭션은 데이터베이스의 데이터 무결성이 보장되는 상태에서 DML 작업을 완수하기 위한 기본 작업 단위입니다. 관계형 데이터베이스 시스템은 데이터를 처리할 때 트랜잭션을 통해 정상 종료나 사용자 프로세스 실패나 시스템 실패와 같은 비정상 종료에 대해 데이터의 신뢰성과 일관성을 보장합니다.,https://thebook.io/006977/ch09/02/01/,
127,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,트랜잭션이 성공적으로 처리되어 데이터베이스의 무결성과 일관성을 보장하려면 4가지 특성 ( ACID )을 만족해야 한다. 원자성은 트랜잭션을 구성하는 연산들이 ‘모두 정상적으로 실행’되거나 ‘하나도 실행되지 않아야 한다’를 의미. 일관성은 트랜잭션이 성공적으로 수행된 후에도 데이터베이스가 일관성 있는 상태를 유지. 고립성은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것. 지속성은 성공적으로 수행된 트랜잭션은 영원히 반영되야 함을 의미.,https://jaeseongdev.github.io/development/2021/06/16/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98-%ED%8A%B9%EC%A7%95-(ACID)/,
128,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션의 성질을 흔히 ACID 로 표현한다. Atomicity(원자성), Consistency(일관성), Isolation(독립성), Durability(영속성)의 앞글자를 따 ACID로 트랜잭션의 성질을 표현한다.",https://tecoble.techcourse.co.kr/post/2021-07-11-database-transaction/,
129,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션이란 DBMS (DB) 에서 데이터에 대한 하나의 논리적 실행단계를 의미한다. 여기서 트랜잭션의 4대 특징이란 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질으로, ACID (Atomicity[원자성] / Consistency[일관성] / Isolation[고립성] / Durability[지속성])로 표현된다. 은행과 같이 트랜잭션의 수행이 안전하게 수행됨을 보장해야 하는 시스템에 주로 사용된다.",https://do-my-best.tistory.com/50,
130,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션의 중요한 특징은 ACID라는 4가지로 구분됩니다.
원자성 - 데이터베이스에 트랜잭션의 수행이 모두 반영되거나 아예 반영되지 않아야 함
일관성 -트랜잭션이 실행을 성공적으로 완료하면 일관성있는 데이터베이스 상태로 유지해야 함.
독립성 -트랜잭션 수행시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 함.
지속성 -성공적으로 수행된 트랜잭션은 영원히 반영되어야 함. ",https://stg0123.github.io/study/33/,
131,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"ACID,
원자성 
트랜잭션의 연산은 반드시 모두 반영되도록 완료되거나, 아니면 전혀 반영되지 않도록 복구되어야한다.
일관성 
트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
격리성
둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없다.
영속성
성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.",https://back-end-developer.tistory.com/62,
132,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,트랜잭션에게는 통칭 ACID라는 특징이 있다. 원자성 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 일관성 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는 것을 의미한다. 독립성 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 지속성 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다.,https://jaehoney.tistory.com/232,
133,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션의 특징 (ACID)
원자성 트랜잭션은 한 개 이상의 동작을 논리적으로 한 개의 작업단위로서 분해가 불가능한 최소의 단위
일관성 트랜잭션이 실행을 성공적으로 완료하면 언제나 모순 없이 일관성 있는 데이터베이스 상태를 보존함.
고립성 트랜잭션이 실행 중에 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근할 수 없음.
지속성 성공이 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장됨.",http://www.jidum.com/jidums/view.do?jidumId=193,
134,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,트랜잭션에는 4가지의 특징이 있습니다. 4가지의 특징의 앞 글 자만 따서 ACID라고도 불립니다. 원자성 -  트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장한다. 일관성 - 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다. 고립성 - 트랜잭션 수행 시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장해야 한다. 영속성 - 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.,https://dkswnkk.tistory.com/555,
135,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"ACID
원자성
- 트랜잭션은 DB 작업의 최소 단위가 되어야한다.
일관성
- 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
고립성
- 각각의 트랜잭션은 서로간에 간섭없이 독립적으로 수행되어야 한다.
지속성
- 트랜잭션이 정상적으로 완료된 후에는 영구적으로 데이터베이스에 작업 결과가 저장되어야 한다.",https://jammdev.tistory.com/118,
136,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션의 특징은 ACID 특성이라 합니다. 원자성
트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장하는 것을 말합니다.
일관성
트랜잭션이 성공적으로 완료되면 일관적인 DB상태를 유지하는 것을 말합니다.
격리성
트랜잭션 수행시 다른 트랜잭션의 작업이 끼어들지 못하도록 보장하는 것을 말합니다.
지속성
성공적으로 수행된 트랜잭션은 영원히 반영이 되는 것을 말합니다",https://victorydntmd.tistory.com/129,
137,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션은 아래와 같은 특징을 가지며, 영문 첫 글자를 따서  ACID라고 부른다.
원자성
트랜잭션은 더 이상 분해가 불가능한 업무의 최소단위이므로, 전부 처리되거나 아예 하나도 처리되지 않아야 한다.
일관성
트랜잭션 실행의 결과로 데이터베이스 상태가 모순되지 않아야 한다.
격리성
실행 중인 트랜잭션의 중간결과를 다른 트랜잭션이 접근할 수 없다.
영속성
트랜잭션이 일단 그 실행을 성공적으로 완료하면 그 결과는 데이터베이스에 영속적으로 저장된다.",https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=362,
138,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"트랜잭션은 데이터베이스에서 하나의 논리적 기능을 수행하기 위해 여러개의 쿼리를 하나로 묶은 작업의 단위이다. 트랜잭션은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolastion), 지속성(Durability) 4가지 특징을 갖는다. 이 앞글자를 따서 ACID 특징 이라고 부른다.",https://hudi.blog/transaction/,
139,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"1. 원자성- 분리 할수 없는 하나의 단위로 작업은 모두 완료되거나, 혹은 모두 취소 되어야 합니다.
2. 일관성- 사용되는 모든 데이터는 일관되어야 합니다.
3. 격리성 - 접근하고 있는 데이터는 다른 트랜잭션으로 부터 격리 되어야 합니다. 
4. 영속성- 트랙잭션이 정상 종료되면 그 결과는 시스템에 영구적으로 적용되어야 합니다.",https://jwprogramming.tistory.com/48,
140,mstr_db_2,kshired,"원자성 - 1.25 점, 일관성 - 1.25 점, 독립성 - 1.25 점, 지속성 - 1.25 점","만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 한다. - 1.25 점, 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다. - 1.25 점, 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다. - 1.25 점, 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다. - 1.25 점",[데이터베이스 2] Transaction의 네가지 특성을 설명해주세요.,"원자성
- 트랜잭션은 분해가 불가능한 최소의 단위로 연산 전체가 처리되거나 처리되지 않아야 한다.
일관성
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 모순 없이 일관성 있는 데이터베이스 상태를 보존
고립성
- 트랜잭션이 실행 중 생성하는 연산의 중간 결과를 다른 트랜잭션이 접근할 수 없음
지속성
- 성공이 완료된 트랜잭션의 결과는 영구적으로 데이터베이스에 저장",https://itpenote.tistory.com/585,
141,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"데드락이 발생하기 위한 조건은 크게 4가지로 말할 수 있습니다. 먼저 상호배제는 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용 중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 합니다. 점유대기는 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 합니다. 비선점은 이미 할당된 자원을 강제로 빼앗을 수 없다는 조건입니다. 순환대기는 이미 할당된 자원을 강제로 빼앗을 수 없다는 조건입니다.",,
142,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"첫번째로 상호배제가 있다. 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
다음으로 점유대기는 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
비선점은 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
순환대기 또한 중요하다. 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이 중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.",,
143,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"아래 4가지 조건이 모두 만족되는 경우 데드락이 발생할 가능성이 있다.
하나라도 만족하지 않으면 절대 발생하지 않는다.
상호 배제(Mutual exclusion)는 한 리소스는 한 번에 한 프로세스만이 사용할 수 있음을 뜻함.
점유와 대기(Hold and wait)는 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리고 있음을 뜻함.
비선점(No preemption)은
프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할 때까지 기다린다는 뜻임. (강제로 빼앗지 않는다)
환형 대기(Circular wait)는 Hold and wait 관계의 프로세스들이 서로를 기다린다는 조건임.",,
144,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"교착 상태는 한 시스템 내에서 다음의 4가지 조건이 동시에 성립할 때 발생한다.


상호 배제(Mutual Exclusion)

: 자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.

점유 대기 (Hold and Wait)

: 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다.

즉, 이미 자원을 사용중인데, 다른 프로세스가 사용중인 자원을 사용하기 위해 대기하고 있는 상태의 프로세스가 존재해야 한다.

비선점 (No preemption)

: 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.

순환 대기 (Circular wait)

: 프로세스의 집합에서 P0은 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고, P2...Pn-1d은 Pn이 점유한 자원을 대기하며 Pn은 P0이 점유한 자원을 요구해야 한다.",,
145,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"Mutual Exclusion(상호 배타적)
하나의 프로세스가 
자원을 독점적으로 사용한다(여러 개가 동시 사용 불가)
No preemption
프로세스가 자원을 가지고 있을 때, 자원을 스스로 내어놓을 뿐 강제로 빼앗기지 않음
Hold and wait
자원을 가진 프로세스가 다른 자원을 기다릴 때 보유 자원을 놓지 않고 계속 가지고 있음
Circular wait
자원을 기다리는 프로세스간에 사이클이 형성되어야 함
프로세스 P0, P1, ... , Pn이 있을 때 Pn-1은 Pn의 자원을 기다리고 Pn은 P0의 자원을 기다려야 한다",,
146,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"교착상태는 아래의 4가지 조건이 모두 만족되는 경우(필요충분조건)에 발생할 가능성이 있으며,
하나라도 만족하지 않으면 교착상태가 발생하지 않습니다.

 

1. 상호 배제(Mutual Exclusion)
한 번에 한 개의 프로세스만이 공유자원을 사용할 수 있음

2. 점유 대기(Hold and Wait)
프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다림

3. 비선점(No Preemption)
프로세스가 작업을 마친 후 자원을 자발적으로 반환할 때까지 기다림
(이미 할당된 자원을 강제적으로 빼앗을 수 없음)

4. 순환 대기(Circular Wait)
프로세스의 자원 점유 및 점유된 자원의 요구 관계가 원형을 이루면서 대기하는 조건.
각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음",,
147,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,몇가지 조건을 모두 만족하면 데드락이 발생할 가능성이 있다. 하나라도 해결되면 발생하지 않는다.,,
148,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"상호 배제, 점유 대기, 비선점, 순환 대기",,
149,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"4가지 모두 성립해야 데드락 발생 (하나라도 성립하지 않으면 데드락 문제 해결 가능)
자원은 한번에 한 프로세스만 사용할 수 있음 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함",,
150,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"하나라도 만족하지 않으면 데드락은 해결된다.
상호 배제 Mutal exclusion
자원은 한번에 하나의 프로세스만 사용할 수 있다. 
하나의 자원을 두 개 이상의 스레드가 점유할 수 없다.
비선점 No preemption
어떤 자원은 그 자원을 점유한 프로세스가 task을 완료 했을 때, 그 프로세스에 의해 자발적으로만 방출된다. 중간에 다른 프로세스가 강제로 뺏을 수 없다.
점유 대기 Hold and wait
어떤 프로세스는 적어도 하나의 자원을 점유한 상태에서 다른 프로세스에 의해 점유된 다른 자원을 추가적으로 얻기를 기다리고 있어야 한다.
순환 대기 Circular wait
스레드와 자원이 순환적으로 꼬리를 물고 기다리는 구조이다. ",,
151,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"식사하는 철학자 문제
5명의 철학자와 5개의포크가 있고 식사를위해서는 한사람당 두 개의 포크가 필요한 상황이다.
한 개의 포크를 두 명 의 철학자가 동시에 사용할 수 없고 (mutual exclusion)
한 철학자는 각각 왼쪽 포크를 가진 상태로 오른쪽 포크를 기다린다. (Hold and wait)
또 철학자는 이미 다른 철학자가 가지고 있는 포크를 빼앗을 수 없다 (No preemption)
원형 테이블이므로 순환 구조를 가진다 (Circular wait)",,
152,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"상호배제 : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
점유대기: 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
비선점 : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
순환대기: 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

",,
153,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"상호배제는 젓가락은 한번에 한 철학자만 사용 가능하다는 점이다.
보유 및 대기는 집어든 젓가락을 계속 들은 채로 반대쪽 젓가락을 기다리는 내용이다.
비선점은 이미 누군가 쥐고있는 젓가락을 뺏을 수 없다.
환형 대기는 모든 철학자는 자신의 오른쪽 철학자가 젓가락을 내려놓기를 기다린다는 내용이다.",,
154,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"자원은 한 번에 한 프로세스만이 사용할 수 있어야 한다.
최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기
  위해 대기하는 프로세스가 있어야 한다.
 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다.
프로세스의 집합 {P0, P1, ,…Pn}에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2…Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.",,
155,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"한 리소스는 한 번에 한 프로세스만 사용할 수 있다. 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 가지고 있는 리소스를 기다리고 있다. 프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할때까지 기다린다.(강제로 빼앗지 않는다)
Hold and wait 관계의 프로세스들이 서로 기다린다.",,
156,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"소한 하나의 자원은 비공유방식(nonsharable mode)으로 점유되어야한다. 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 한다. 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 한다. 프로세스의 집합 {P0,P1,...,Pn에서 P0는 P1이 점유한 자원을 대기하고 P1은 P2가 점유한 자원을 대기하고 P2...Pn-1은 Pn이 점유한 자원을 대기하며 Pn은 P0가 점유한 자원을 요구해야 한다.",,
157,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"교착상태가 발생하기 위해서는 4가지 조건이 만족해야 합니다.
첫번째는 상호 배제로 한 리소스는 한번에 한 프로세스만이 사용할 수 있다.
두번째는 점유와 대기로 어떤 프로세스가 하나의 리소스를 점유하는 동시에 다른 프로세스가 해당 리소스를 기다린다.
세번째는 비선점으로 프로세스가 태스크를 선점하지 않고 반환할 때까지 기다린다.
네번째는 환형 대기로 프로세스들이 서로를 기다린다.",,
158,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"상호 배제는 프로세스가 자원을 사용할 때 다른 프로세스와 동시에 사용할 수 없는 조건을 의미합니다.
두번째로 점유 및 대기는 
한 자원을 점유한 상태에서 다른 자원을 요청하기 위해 대기할 수 있는 조건을 의미합니다. 비선점은
한 프로세스가 자원을 할당 받으면 작업이 끝날 때 까지 시스템에서 제어권을 뺏을 수 없는 조건을 의미합니다.
순환 대기는 여러개의 프로세스가 서로의 자원을 요청하고 있는 상태를 의미합니다.",,
159,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"다음 4가지를 모두 만족하여야 교착상태가 발생할 수 있다.
1.
상호 배제 (mutual exclusion)
프로세스가 자원을 사용할 때 다른 프로세스와 동시에 사용할 수 없는 조건을 의미한다.
2.
점유 및 대기 (hold and wait)
한 자원을 점유한 상태에서 다른 자원을 요청하기 위해 대기할 수 있는 조건을 의미한다.
3.
비선점 (nopreemption)
한 프로세스가 자원을 할당 받으면 작업이 끝날 때 까지 시스템에서 제어권을 뺏을 수 없는 조건을 의미한다.
4.
순환 대기 (circular-wait)
여러개의 프로세스가 서로의 자원을 요청하고 있는 상태를 의미한다.",,
160,mstr_os_1,big jo,"상호 배제 - 1.25점, 점유 대기 - 1.25점, 비선점 - 1.25점, 순환 대기 - 1.25점","상호 배제에 대한 내용 -> 한 번에 프로세스 하나만 해당 자원을 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다. - 1.25점, 점유 대기에 대한 내용 -> 자원을 최소한 하나 보유하고, 다른 프로세스에 할당된 자원을 점유하기 위해 대기하는 프로세스가 존재해야 한다 - 1.25점, 비선점에 대한 내용 → 이미 할당된 자원을 강제로 빼앗을 수 없다. - 1.25점, 순환 대기에 대한 내용 -> 대기 프로세스의 집합이 순환 형태로 자원을 대기하고 있어야 한다. - 1.25점",[운영체제 1] Deadlock의 발생조건 네가지를 간단히 설명해주세요.,"데드락이 발생하는 상황은 다음과 같다.

멀티 프로그래밍 환경에서 한정된 자원을 얻기 위해 서로 경쟁하는 상황 발생
한 프로세스가 자원을 요청했고 동시에 그 자원을 사용할 수 없는 상황이 발생할때 해당 프로세스는 대기 상태로 들어간다.
대기 상태로 들어간 프로세스들이 실행 상태로 변경될 수 없을 때의 상황을 교착상태(DeadLock)라고 한다.
",,
161,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"기본 키는 주 키 또는 프라이머리 키라고 하며, 관계형 데이터베이스에서 조(레코드)의 식별자로 이용하기에 가장 적합한 것을 관계 (테이블)마다 단 한 설계자에 의해 선택, 정의된 후보 키를 말한다. ",,
162,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키는 후보키 중에서 선택한 주키(Main Key)이다. 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. Null값을 가질 수 없다. 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.,,
163,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"기본키는 주 키 또는 프라이머리 키라고 하며, 후보키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없으며, 후보키의 성질을 갖는다. 즉, 유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다. ",,
164,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키는 릴레이션을 대표하는 키다. 때문에 기본키를 설정하면 다른 릴레이션의 외래키와 관계를 맺고 상호작용 할 수 있다.,,
165,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,후보키 중에서 선택한 주키(Main Key)로 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성을 가지며 Null 값을 가질 수 없습니다,,
166,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키는 후보키 중에서 특별히 선정된 주키(Main Key)이며 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키는 중복된 값을 가질 수 없으며 NULL값을 가질 수 없다,,
167,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"기본키는 DB에서 Primary Key라고 부릅니다. 
이걸 정하는 이유는 데이터를 보다 명확하게 구분하고 찾기 위해서죠.",,
168,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,후보 키 중에서 레코드들의 식별자로 선택한 하나의 키,,
169,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키는 후보키 중 하나를 선정하여 대표로 삼는 키를 말한다. 후보키가 하나뿐이라면 그 후보키를 기본키로 사용하면 되고 여러 개라면 릴레이션의 특성을 반영하여 하나를 선택하면 된다.,,
170,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,후보키들 중에서 하나를 선택한 키로 최소성과 유일성을 만족하는 속성이다.,,
171,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키 역시 DBMS에서 테이블에 설정하는 하나의 제약 조건 중 하나입니다. 기본키 제약 조건은 테이블 내에서 유일하게 존재하는 값의 조합을 설정해서 중복된 데이터가 테이블에 삽입되는 것을 방지하는 제약 조건입니다,,
172,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"설계자가 여러 후보키 중 하나를 선택하여 정의한 식별자 (유일성, 최소성)기본키의 모든 필드의 값은 null 이 될 수 없다.",,
173,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"각 행마다 행을 식별할 수 있도록 전부 다른 값이 저장된 열을 찾으셨다면, 그 열을 가지고 기본 키를 만들 수 있습니다. 다시 한번 강조하자면, 기본 키는 테이블 내의 각 행을 고유하게 하는 열입니다. 고로, 기본 키는 모든 행이 고유한 값을 가지고 있는지 혹은 값이 비어있는 행이 있는지 확인할 수 있도록 합니다. 예를 들어, 여러분이 이미 어떤 열에 존재하는 값을 새로운 행을 만들어서 추가하고자 한다면, 이는 기본 키에 의해서 생성이 제한됩니다. 

또한, 기본 키는 NULL 값을 받아들이지 않습니다. 즉, 기본 키 열에는 NULL 값이 존재할 수 없습니다. 미국 시민의 정보를 저장하고 있는 테이블인 citizen 예시가 기억나십니까? 만약 social_security_number 열에 NULL 값이 포함된 행을 추가하고자 한다면, 이는 기본 키에 의해서 제지 당합니다. 다시 말해서, 기본 키는 기본 키가 되는 열의 행 값이 고유하고 비어있지 않도록 만들어 줍니다.",,
174,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,기본키(Primary Key)는 관계형 데이터 베이스에서 식별자로 사용하기 위해 테이블마다 하나씩 존재하는 데이터를 말합니다. 기본키가 될 수 있는 컬럼들을 후보 키(Candidate Key)라고 하며 기본키는 후보 키들 중 하나를 선택한 컬럼이라고 할 수 있습니다.,,
175,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"PRIMARY KEY 제약 조건을 설정하면, 해당 필드는 NOT NULL과 UNIQUE 제약 조건의 특징을 모두 가집니다.

따라서 이 제약 조건이 설정된 필드는 NULL 값을 가질 수 없으며, 또한 중복된 값을 가져서도 안 됩니다.

이러한 PRIMARY KEY 제약 조건을 기본 키라고 합니다.",,
176,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,후보키는 여러개가 존재할 수 있는데 여기서 우리는 여러 후보키 중에서 하나를 선택해서 사용해야 하며 여기서 선택된 키가 기본키입니다.,,
177,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,후보키(candidate key)중 데이터베이스 설계자가 선정하는 하나의 키,,
178,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,"기본키(primary key)는 여러 후보키 중 하나를 선정해 대표로 삼는 키.
후보키가 하나뿐이라면 그 후보키를 기본키로 사용하면 되고 여러 개라면 릴레이션의 특성을 반영해 하나 선택하면 됨.

기본키는 릴레이션을 대표하므로 여러 사항을 고려해야 한다.
예를 들어 저자 릴레이션의 경우 '저자번호', 'URL'을 기본키로 선택할 수 있다. 먼저 URL을 보면, 저자에게 각각 주어지며 변경이 불가능하다. 변경이 불가능하면 튜플 식별 시 자료변형에 잘 대처할 수 있는 여지를 제공.
그러나 URL은 속성의 값이 다른 데이터에 비해 큰 편이라 데이터 계산 속도에 영향을 줄 수 있다.
따라서 기본키로 저자번호를 선택하는 것이 좋다.",,
179,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다. 기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없다.,,
180,mstr_db_1,big jo,"식별자 - 1점, 유일성 - 1점, 최소성 - 1점, 불변성 - 1점, 대표성 - 1점","후보키 중 엔티티를 대표할 수 있는 키 - 1점, 특정 튜플을 유일하게 구별할 수 있는 속성 - 1점, 키를 구성하는 속성들 중 꼭 필요한 최소한의 속성들로만 키를 구성 - 1점, NULL 값을 가질 수 없다 - 1점, 자주 변경되지 않아야 한다 - 1점",[데이터베이스 1] Primary key가 무엇인지 설명해주세요.,여러 후보키 중 대표적인 키 하나를 선택해 테이블의 기본 키로 만든다.,,
181,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,카디널리티가 높으면 인덱스 설정에 좋은 컬럼이다.  선택도가 낮으면 인덱스 설정에 좋은 컬럼이다. 조회 활용도가 높으면 인덱스 설정에 좋은 컬럼이다. 수정 빈도가 낮으면 인덱스 설정에 좋은 컬럼이다.,,
182,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"전체 행에 대한 특정 컬럼의 데이터 중복 수치에 대한 정보를 기수성(Cardinality)라고 합니다. 중복되는 횟수가 높으면 기수성 값이 낮고, 중복되는 횟수가 낮으면 기수성 값이 높다고 표현합니다.선택도는 기수성으로부터 계산할 수 있습니다. 선택도가 수식을 보면 알 수 있듯이 기수성 값이 높을수록 선택도 또한 같이 높아집니다. 선택도가 ‘1’ 이라는 의미는 모든 값이 유일(unique)하다는 의미입니다. 높은 선택도를 가지는 컬럼을 인덱스로 설정하는 경우 조회 성능이 향상됩니다.",,
183,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋습니다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성됩니다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋습니다. 가장 최선은 PK로 인덱스를 거는것이겠죠. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고. 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것입니다.,,
184,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"조건절에 자주 등장하는 컬럼, LIKE 검색보다는 = 으로 검색하는 컬럼, ORDER BY 절에서 자주 사용되는 컬럼, JOIN으로 자주 사용되는 컬럼",,
185,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"접근 경로 표를 기준으로 어떤 컬럼이 자주 사용되는 지를 판단하고 해당 컬럼의 분포도를 조사해야 한다.

분포도란 Cardinality라고 하며 한 컬럼에 얼마나 다양한 값이 어떻게 분포되어 있는 지를 나타낸다.",,
186,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋다. 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다. 이 기준 컬럼은 최대한 중복이 되지 않는 값이 좋다. 가장 최선은 PK로 인덱스를 거는 것이라고 할 수 있다. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고, 반대로 모든 값이 같은 컬럼의 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야 할 것이다.",,
187,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"1개의 컬럼만 인덱스를 걸어야 한다면, 해당 컬럼은 카디널리티(Cardinality)가 가장 높은 것을 잡아야 한다는 점입니다.

카디널리티(Cardinality)란 해당 컬럼의 중복된 수치를 나타냅니다.
예를 들어 성별, 학년 등은 카디널리티가 낮다고 얘기합니다.
반대로 주민등록번호, 계좌번호 등은 카디널리티가 높다고 얘기합니다.

인덱스로 최대한 효율을 뽑아내려면, 해당 인덱스로 많은 부분을 걸러내야 하기 때문입니다.
만약 성별을 인덱스로 잡는다면, 남/녀 중 하나를 선택하기 때문에 인덱스를 통해 50%밖에 걸러내지 못합니다.
하지만 주민등록번호나 계좌번호 같은 경우엔 인덱스를 통해 데이터의 대부분을 걸러내기 때문에 빠르게 검색이 가능합니다.",,
188,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,조회시 자주 사용하는 컬럼에 고유한 값 위주로 카디널리티가 높은 곳에 적용해야 한다.,,
189,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼",,
190,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼, 데이터의 중복도가 낮은 컬럼",,
191,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"조건절에 항상 사용되거나, 적어도 자주 사용되는 컬럼들을 선정하고  '='조건으로 자주 조회되는 컬럼을 앞쪽에 두어야 한다.",,
192,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"규모가 작지 않은 테이블에서 INSERT, UPDATE, DELETE가 자주 발생하지 않는 컬럼에 적용해야 합니다.",,
193,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼에 Index를 걸어주어야 합니다.,,
194,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"데이터의 중복도가 낮은 컬럼, 즉 카디널리티가 높은 컬럼이 적합하다.",,
195,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,데이터의 중복도가 낮아서 분포도가 높은 컬럼에 대해 인덱스를 사용해야 한다.,,
196,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,일반적으로 카디널리티가 높은 컬럼을 우선적으로 인덱싱하는 것이 검색 성능에 유리합니다. 카디널리티란 특정 데이터 집합의 유니크한 값의 개수를 의미합니다.,,
197,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,데이터의 중복도가 낮은 칼럼을 사용하는 것이 유리하다.,,
198,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"인덱스는 테이블마다 하나 혹은 여러 개의 컬럼에 대해 설정할 수 있다. 단일 인덱스를 여러 개 생성할 수도 있고, 여러 컬럼을 묶어 복합 인덱스를 설정할 수도 있다.

그러나 무조건 인덱스를 많이 설정하는 것이 검색 속도를 향상시키는 데 도움을 주지 않는다. 인덱스는 데이터베이스의 저장 공간을 사용해 테이블 형태로 저장되므로 개수와 저장 공간은 비례한다.

따라서, 조회 시 자주 사용하고 고유한 값 위주로 인덱스를 설정하는 것이 성능에 도움이 된다.",,
199,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"테이블의 행이 적은 테이블이나 where 로 조건을 줘서 검색할때 10~15% 의 결과보다 높게 리턴될때나 테이블이 자주 입력,수정,삭제 되는 테이블에는 인덱스를 생성,사용하지 않는게 맞다.",,
200,mstr_db_3,big jo,"카디널리티 - 1.25점, 선택도 - 1.25점, 수정 빈도 - 1.25점, 조회 빈도 - 1.25점","상대적으로 중복 정도가 낮은 column - 1점, 특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체 레코드 수로 나눈 값이 낮은 column - 1점, 실제 작업에서 자주 활용되는 column - 1점, 삽입, 삭제, 변경이 적게 일어나는 column - 1점, 조건절에서 많이 사용되는 column - 1점",[데이터베이스 3] DB Index를 어떤 특징을 가진 column에 사용하면 좋을지 설명해주세요.,"인덱스 컬럼의 분포도가 10~15% 이내인 컬럼이며 부분처리를 목적으로 하는 경우, 입출력 장표 등에서 조회 및 출력조건으로 사용되는 경우, 수정이 빈번하지 않은 경우에 인덱스로 사용해야 한다.",,